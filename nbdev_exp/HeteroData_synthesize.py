# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/021_HetroData_synthesize.ipynb (unless otherwise specified).

__all__ = ['synthesize_mixing_vector', 'generate_positive_negative_data', 'get_data_list']

# Cell
import numpy as np
import torch
import torch_geometric
from sklearn.utils import shuffle
from typing import Tuple
import pytorch_lightning as pl
from torch.nn import Linear
from torch_geometric.data import HeteroData
from pathlib import Path
from torch_geometric.nn import GCNConv, SAGEConv ,HeteroConv


# Cell
def synthesize_mixing_vector(length, random_state=46, **kwargs):
    """

    Args:
        length (int) : length = number_of_nodes*number of features
        random_state (int): seed for random shuffling

    Returns:
        np.ndarray mixing vector
    """
    indices = np.arange(length)
    return shuffle(indices, random_state=random_state)


def generate_positive_negative_data(length, total_samples=10000, **kwargs):
    """

    Args:
        length (int) : length = number_of_nodes*number of features
        total_samples (int): total number of instances
        **kwargs:

    Returns:
        Tuple[np.ndarray,np.ndarray] for positive and negative data
    """
    mixing_vec_pos = synthesize_mixing_vector(length, **kwargs)
    A_pos = np.random.randn(length, length)
    cov_pos = np.matmul(A_pos.T, A_pos)
    mean_pos = np.amax(np.abs(cov_pos.flatten())) * (1 + np.random.randn(length) * 0.25)
    raw_samples_pos = np.random.multivariate_normal(mean_pos, cov_pos, size=total_samples)
    samples_pos = raw_samples_pos[:, mixing_vec_pos]

    mixing_vec_neg = synthesize_mixing_vector(length, **kwargs)
    A_neg = np.random.randn(length, length)
    cov_neg = np.matmul(A_neg.T, A_neg)
    mean_neg = np.amax(np.abs(cov_neg.flatten())) * (-1 + np.random.randn(length) * 0.25)
    raw_samples_neg = np.random.multivariate_normal(mean_neg, cov_neg, size=total_samples)
    samples_neg = raw_samples_neg[:, mixing_vec_neg]
    return samples_pos, samples_neg


# noinspection PyPep8Naming
def get_data_list(number_of_nodes=15, number_of_features=5, total_samples=10000):
    X_p, X_n = generate_positive_negative_data(number_of_nodes * number_of_features, total_samples)
    Y = [0] * X_n.shape[0] + [1] * X_p.shape[0]
    X_p = np.reshape(X_p, (total_samples, number_of_nodes, number_of_features))
    X_n = np.reshape(X_n, (total_samples, number_of_nodes, number_of_features))
    X = np.concatenate([X_n, X_p], axis=0)
    edge_index_dict = {"type1": [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
                                 [0, 0, 0, 0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4]],
                       "type2": [[0, 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14],
                                 [1, 5, 7, 7, 9, 6, 7, 9, 14, 11, 6, 7, 7, 13]]}
    data_list = [HeteroData(
        {"y": torch.tensor(y,dtype=torch.long),
         "node_a": {"x": torch.tensor(x,dtype=torch.float32)},
         ("node_a", "love", "node_a"): {"edge_index": torch.tensor(edge_index_dict["type1"],dtype=torch.long)},
         ("node_a", "hate", "node_a"): {"edge_index": torch.tensor(edge_index_dict["type2"],dtype=torch.long)}
         })
        for x, y in zip(X, Y)]
    return data_list

# Cell
from nbdev.export import notebook2script;

notebook2script()
#
# notebook2script()